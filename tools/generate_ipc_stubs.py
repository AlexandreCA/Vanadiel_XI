# On a build this script is automatically run, generating build/generated/ipc_stubs.h, which contains:
# - MessageType enum
# - getEnumType(MessageType) helper
# - toString(MessageType) helper
# - IIPCMessageHandler interface


# fmt: off
import os
import sys


# TODO: Make this generic so you can specify an output filename, namespace name, interface name, enum name, etc.


# Define the struct names that will be used to generate build/generated/ipc_stubs.h
IPC_STRUCT_NAMES = [
    "EmptyStruct",

    "CharLogin",
    "CharZone",
    "CharVarUpdate",

    "ChatMessageTell",
    "ChatMessageParty",
    "ChatMessageAlliance",
    "ChatMessageLinkshell",
    "ChatMessageUnity",
    "ChatMessageYell",
    "ChatMessageServerMessage",
    "ChatMessageCustom",

    "PartyInvite",
    "PartyInviteResponse",
    "PartyReload",
    "PartyDisband",

    "AllianceReload",
    "AllianceDissolve",

    "PlayerKick",

    "MessageStandard",
    "MessageSystem",

    "LinkshellRankChange",
    "LinkshellRemove",
    "LinkshellSetMessage",

    "LuaFunction",

    "KillSession",

    "ConquestEvent",
    "BesiegedEvent",
    "CampaignEvent",
    "ColonizationEvent",

    "EntityInformationRequest",
    "EntityInformationResponse",

    "SendPlayerToLocation",
]


def generate_ipc_stubs(output_dir, struct_names):
    output_path = os.path.join(output_dir, "generated")
    print(f"Generating ipc stubs...\nOutput path: {output_path}")

    os.makedirs(output_path, exist_ok=True)

    ipc_stub_file = os.path.join(output_path, "ipc_stubs.h")
    with open(ipc_stub_file, "w") as f:
        f.write(f"// This file is auto-generated by tools/generate_ipc_stubs.py\n")
        f.write(f"// Do not modify this file directly.\n\n")
        f.write(f"#pragma once\n\n")
        f.write(f"#include <cstdint>\n")
        f.write(f"#include <span>\n\n")
        f.write(f"#include <type_traits>\n\n")
        f.write(f"#include \"common/ipc_structs.h\"\n")
        f.write(f"#include \"common/ipp.h\"\n\n")
        f.write(f"#include \"common/logging.h\"\n\n")
        f.write(f"namespace ipc\n{{\n\n")

        generate_message_type_enum(f, struct_names)
        generate_struct_completion_traits(f)
        generate_get_enum_type_function(f, struct_names)
        generate_enum_to_string_function(f, struct_names)
        generate_message_handler_interface(f, struct_names)

        f.write(f"}} // namespace ipc\n")


def generate_message_type_enum(file, struct_names):
    max_name_length = max(len(name) for name in struct_names)

    file.write(f"enum class MessageType : uint8_t\n{{\n")

    file.write(f"    // 0 is reserved for unknown messages\n\n")

    for idx, name in enumerate(struct_names, 1):
        file.write(f"    {name.ljust(max_name_length)} = {idx},\n")

    file.write(f"}};\n\n")


def generate_struct_completion_traits(file):
    file.write("template <typename T, typename = void>\n")
    file.write("struct is_struct_complete : std::false_type {};\n\n")

    file.write(f"template <typename T>\n")
    file.write(f"struct is_struct_complete<T, std::void_t<decltype(sizeof(T))>> : std::true_type {{}};\n\n")


def generate_get_enum_type_function(file, struct_names):
    file.write(f"template <typename T>\n")
    file.write(f"constexpr auto getEnumType() -> MessageType\n")
    file.write(f"{{\n")
    file.write(f"    static_assert(is_struct_complete<T>::value, \"You must fully define this struct in common/ipc_structs.h.\");\n\n")
    file.write(f"    using UnderlyingT = std::decay_t<T>;\n\n")

    counter = 0
    for name in struct_names:
        if counter == 0:
            file.write(f"    if constexpr (std::is_same_v<UnderlyingT, {name}>)\n")
        else:
            file.write(f"    else if constexpr (std::is_same_v<UnderlyingT, {name}>)\n")

        file.write(f"    {{\n")
        file.write(f"        return MessageType::{name};\n")
        file.write(f"    }}\n")

        counter += 1

    file.write(f"}}\n\n")


def generate_enum_to_string_function(file, struct_names):
    file.write(f"constexpr auto toString(MessageType type) -> std::string\n")
    file.write(f"{{\n")
    file.write(f"    switch (type)\n")
    file.write(f"    {{\n")

    for name in struct_names:
        file.write(f"        case MessageType::{name}:\n")
        file.write(f"            return \"{name}\";\n")

    file.write(f"        default:\n")
    file.write(f"            return \"Unknown\";\n")
    file.write(f"    }}\n")
    file.write(f"}}\n\n")


def generate_message_handler_interface(file, struct_names):
    file.write(f"class IIPCMessageHandler\n")
    file.write(f"{{\n")
    file.write(f"public:\n")
    file.write(f"    virtual ~IIPCMessageHandler() = default;\n\n")

    file.write(f"    void handleMessage(const IPP& ipp, const std::span<uint8_t> message)\n")
    file.write(f"    {{\n")
    file.write(f"        const auto messageType = static_cast<MessageType>(message[0]);\n")
    file.write(f"        switch (messageType)\n")
    file.write(f"        {{\n")

    for name in struct_names:
        file.write(f"            case MessageType::{name}:\n")
        file.write(f"            {{\n")
        file.write(f"                const auto object = ipc::fromBytesWithHeader<{name}>(message);\n")
        file.write(f"                if (!object.has_value())\n")
        file.write(f"                {{\n")
        file.write(f"                    ShowError(\"Failed to deserialize {name} message.\");\n")
        file.write(f"                    break;\n")
        file.write(f"                }}\n")
        file.write(f"                handleMessage_{name}(ipp, *object);\n")
        file.write(f"            }}\n")
        file.write(f"            break;\n")

    file.write(f"            default:\n")
    file.write(f"                handleUnknownMessage(ipp, message);\n")
    file.write(f"                break;\n")
    file.write(f"        }}\n")
    file.write(f"    }}\n\n")
    file.write(f"protected:\n")

    for name in struct_names:
        file.write(f"    virtual void handleMessage_{name}(const IPP& ipp, const ipc::{name}& message) = 0;\n")

    file.write(f"\n    virtual void handleUnknownMessage(const IPP& ipp, const std::span<uint8_t> message) = 0;\n")

    file.write(f"}};\n\n")


if __name__ == "__main__":
    current_path = os.path.dirname(os.path.realpath(__file__))
    output_directory = os.path.join(current_path, sys.argv[1])

    generate_ipc_stubs(output_directory, IPC_STRUCT_NAMES)
